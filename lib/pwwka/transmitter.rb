module Pwwka
  # Primary interface for sending messages.
  #
  # Example:
  #
  #     # Send a message, blowing up if there's any problem
  #     Pwwka::Transmitter.send_message!({ user_id: @user.id }, "users.user.activated")
  #
  #     # Send a message, logging if there's any problem
  #     Pwwka::Transmitter.send_message_safely({ user_id: @user.id }, "users.user.activated")
  class Transmitter

    extend Pwwka::Logging
    include Pwwka::Logging

    attr_reader :channel_connector
    def initialize
      @channel_connector = ChannelConnector.new 
    end

    # Send an important message that must go through.  This method allows any raised exception 
    # to pass through.
    #
    # payload:: Hash of what you'd like to include in your message
    # routing_key:: String routing key for the message
    #
    # Returns true
    #
    # Raises any exception generated by the innerworkings of this library.
    def self.send_message!(payload, routing_key)
      new.send_message!(payload, routing_key)
      info "AFTER Transmitting Message on #{routing_key} -> #{payload}"
    end

    # Send a less important message that doesn't have to go through. This eats
    # any `StandardError` and logs it, returning false rather than blowing up.
    #
    # payload:: Hash of what you'd like to include in your message
    # routing_key:: String routing key for the message
    #
    # Returns true if the message was sent, false otherwise
    def self.send_message_safely(payload, routing_key)
      send_message!(payload, routing_key)
    rescue => e
      error "ERROR Transmitting Message on #{routing_key} -> #{payload}: #{e}"
      false
    end

    def send_message!(payload, routing_key)
      info "START Transmitting Message on #{routing_key} -> #{payload}"
      channel_connector.topic_exchange.publish(
        payload.to_json,
        routing_key: routing_key,
        persistent: true)
      channel_connector.connection_close
      # if it gets this far it has succeeded
      info "END Transmitting Message on #{routing_key} -> #{payload}"
      true
    end

    def send_delayed_message!(payload, routing_key, delay_by = 5000)
      info "START Transmitting Delayed Message on #{routing_key} -> #{payload}"
      delayed_queue
      channel_connector.delayed_exchange.publish(
        payload.to_json,
        routing_key: routing_key,
        expiration: delay_by,
        persistent: true)
      channel_connector.connection_close
      # if it gets this far it has succeeded
      info "END Transmitting Delayed Message on #{routing_key} -> #{payload}"
      true
    end

    private
    def delayed_queue
      @delayed_queue ||= begin
        queue = channel_connector.channel.queue( "pwwka_delayed_#{Pwwka.environment}", durable: true,
          arguments: {
            'x-dead-letter-exchange' => channel_connector.configuration.topic_exchange_name,
        })
        queue.bind(channel_connector.delayed_exchange)
        queue
      end 
    end

  end
end
